# Singleton Design pattern
Special class which can have only one object

- Create Private constructor
- Create a static instance that return the same instance every time

## Initial Code
```cpp
#include <bits/stdc++.h>
using namespace std;

class Singleton{
    private:
        static Singleton* instance;
        
        Singleton(){
            cout<<"New Object Created\n";
        }
        
    public:
        // Static so everyone can call this method without creating object of Singleton class
        static Singleton* getInstance(){
            if(instance == nullptr){
                instance = new Singleton();
            }
            return instance;
        }
};

Singleton* Singleton::instance = nullptr;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    
    cout<<(s1 == s2)<<endl;

    return 0;
}
```

### Problem with this code
- In case of multi threading if more than 1 thread get executed simultaneously, then both will have instance == nullptr means two object will be created, this break Singlethon

### Solution : Use Lock
- we will use lock to prevent multiple thread to access the shared resource simultaneously

#### Way1
```cpp
#include <bits/stdc++.h>
using namespace std;

class Singleton{
    private:
        static Singleton* instance;
        static mutex mtx;
        
        Singleton(){
            cout<<"New Object Created\n";
        }
        
    public:
        static Singleton* getInstance(){
            lock_guard<mutex> lock(mtx);
            if(instance == nullptr){
                instance = new Singleton();
            }
            return instance;
        }
};

Singleton* Singleton::instance = nullptr;
mutex Singleton::mtx;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    
    cout<<(s1 == s2)<<endl;
}
```
- Problem with this is, we should use lock where is essentially needed, as it is very expensive operation
- thus, we will use lock in if condition

#### Way2
```cpp
#include <bits/stdc++.h>
using namespace std;

class Singleton{
    private:
        static Singleton* instance;
        static mutex mtx;
        
        Singleton(){
            cout<<"New Object Created\n";
        }
        
    public:
        static Singleton* getInstance(){
            /*  
                This Fails, because if two thread enter the if condition simultaneously then lock will work still both thread will create two new object

                if(instance == nullptr){
                    lock_guard<mutex> lock(mtx);
                    instance = new Singleton();
                }
            */
            if(instance == nullptr){
                lock_guard<mutex> lock(mtx);

                // Thus solution to that: we will use double locking

                if(instance == nullptr){
                    instance = new Singleton();
                }
            }
            return instance;
        }
};

Singleton* Singleton::instance = nullptr;
mutex Singleton::mtx;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    
    cout<<(s1 == s2)<<endl;
}
```

#### Way3 (without using lock) : Eager Initialization
- initialize the instance before main function

```cpp
#include <bits/stdc++.h>
using namespace std;

class Singleton{
    private:
        static Singleton* instance;
        
        Singleton(){
            cout<<"New Object Created\n";
        }
        
    public:
        static Singleton* getInstance(){
            return instance;
        }
};

Singleton* Singleton::instance = new Singleton();

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    
    cout<<(s1 == s2)<<endl;
}
```

**Problem with this** : if Singleton() object uses lots of memory, and we don't even used that object so this will be waste of memory. Thats why it is not recommended to use like this.

**Use only** when objet is memory light weight 


## Practical Use Case
- Logging System
- Database Connection
- Configuration Manager


# Strategy Pattern

## Initial Case
- `Robot` : walk(), talk(), abstract method - projection()
- `CompanionRobot : Robot` and `

**Way1: fly() in concrete classes**
```mermaid
classDiagram
class Robot{
    walk()
    talk()
    projection() 
}

Robot <|-- CompanionRobot
Robot <|-- WorkerRobot
Robot <|-- SparrowRobot
Robot <|-- CrewRobot

class SparrowRobot{
    fly()
}

class CrewRobot{
    fly()
}
```
- This will voilate **DRY (Do not Repeate Yourself) Principle** , as fly() is written in every class which has fly behaviour.

**way2: fly() in parent class**
```mermaid
classDiagram
class Robot{
    walk()
    talk()
    fly()
    projection() 
}

Robot <|-- CompanionRobot
Robot <|-- WorkerRobot
Robot <|-- SparrowRobot
Robot <|-- CrewRobot

```
- Thus we will give fly() behaviour to Parent `Robot` class
- This will break `Dependency Inversion Principle` as fly() is not needed in `CompanionRobot` and `WorkerRobot` class.

**Way3: Inheritance**
```mermaid
classDiagram
class Robot{
    walk()
    talk()
    projection() 
}

class Flyable{
    fly()
}

Robot <|-- Flyable
Robot <|-- CompanionRobot
Robot <|-- WorkerRobot
Flyable <|-- SparrowRobot
Flyable <|-- CrewRobot

Flyable <|-- JetRobot1
Flyable <|-- JetRobot2

class JetRobot1{
    fly()
}

class JetRobot2{
    fly()
}
```
- **here** JetRobot1, JetRobot2 will fly() but it there own way (using jet and both have different projection), again fly() repeated in both JetRobot class and DRY Principle is break.

**Way4: Solution of Way3 (extend JetWay)**
```mermaid

classDiagram
class Robot{
    walk()
    talk()
    projection() 
}

class Flyable{
    fly()
}

Robot <|-- Flyable

Flyable <|-- FlyWithJet
Flyable <|-- FlyWithWing


Robot <|-- CompanionRobot
Robot <|-- WorkerRobot

FlyWithWing <|-- SparrowRobot
FlyWithWing <|-- CrewRobot

FlyWithJet <|-- JetRobot1
FlyWithJet <|-- JetRobot2

class JetRobot1{
    fly()
}

class JetRobot2{
    fly()
}
```
- And this behavior continue, some new robot come that will NonWalkable, NonTalkable and so on

**Way5: Problem Continues**
```mermaid
classDiagram
%% Base Robot
class Robot

%% Talk trait
class Talkable
class NonTalkable
Robot <|-- Talkable
Robot <|-- NonTalkable

%% Walk trait
class TalkWalkable
class TalkNonWalkable
class NonTalkWalkable
class NonTalkNonWalkable
Talkable <|-- TalkWalkable
Talkable <|-- TalkNonWalkable
NonTalkable <|-- NonTalkWalkable
NonTalkable <|-- NonTalkNonWalkable

%% Fly trait
class TalkWalkFlyable
class TalkWalkNonFlyable
class TalkNonWalkFlyable
class TalkNonWalkNonFlyable
class NonTalkWalkFlyable
class NonTalkWalkNonFlyable
class NonTalkNonWalkFlyable
class NonTalkNonWalkNonFlyable

TalkWalkable <|-- TalkWalkFlyable
TalkWalkable <|-- TalkWalkNonFlyable

TalkNonWalkable <|-- TalkNonWalkFlyable
TalkNonWalkable <|-- TalkNonWalkNonFlyable

NonTalkWalkable <|-- NonTalkWalkFlyable
NonTalkWalkable <|-- NonTalkWalkNonFlyable

NonTalkNonWalkable <|-- NonTalkNonWalkFlyable
NonTalkNonWalkable <|-- NonTalkNonWalkNonFlyable
```
- and so on, so inheritance is not the solution here
- **Note** The solution to Inheritance is not more Inheritance

### Problems with Inheritance
- Code Reusability
- To add new feature lots of changes need to make
- Break Open Close Principle

## Strategy Design Pattern
- Define a family of algorithm, put them into seperate classes so that they can be changed at runtime.
```mermaid
classDiagram
class RobotInitial{
    talk() 
    walk()
    fly()
    projection()
}
```
```mermaid
classDiagram
class Robot{
    talk : Talkable
    walk : Walkable
    fly : Flyable
    projection()

    talk()
    walk()
    fly()
}

Robot o-- Talkable : "has-a"
Robot o-- Walkable : "has-a"
Robot o-- Flyable : "has-a"

class Talkable{
    <<abstract>>
    talk()
}
class NormalTalk{
    talk()
}
class NoTalk{
    talk()
}
Talkable <|-- NormalTalk
Talkable <|-- NoTalk

class Walkable{
    <<abstract>>
    walk()
}
class NormalWalk{
    walk()
}
class NoWalk{
    walk()
}
Walkable <|-- NormalWalk
Walkable <|-- NoWalk

class Flyable{
    <<abstract>>
    fly()
}
class NormalFly{
    fly()
}
class NoWalk{
    fly()
}
Flyable <|-- NormalFly
Flyable <|-- NoFly

class CompanionRobot{
    projection()
}

class WorkerRobot{
    projection()
}
Robot <|-- CompanionRobot : "is-a"
Robot <|-- WorkerRobot : "is-a"
```
- `talk()`, `walk()` and `fly()` are that is changing and `projection()` is same as it will be override by each class.
- so we will take out the chaning mehtods, keep only which does not change

- **Here** We are using Composition over Inheritance
- `Robot` is dumb object now : dont' do any work from it own, delegate to other classes
    - for talk() --> Talkable
    - for walk() --> Walkable
    - for fly() --> Flyable

```cpp
int main(){
    Robot* robot = new CompanionRobot(new NormalTalk(), new NoWalk(), new NormalFly());
    // Here we can change at runtime
}
```

### Notes
- Favor Composiiton over Inheritance
- Encapsulate the methods that varies

## Code
[Strategy Design Pattern Example C++ Code](DesignPatternCode/StrategyPattern.cpp)

## Standard UML Diagram of Strategy Pattern
```mermaid
classDiagram
class Client{
    strategies : Strategy
    execute()
}

Client o-- Strategy : "has-a"

class Strategy{
    <<abstract>>
    run()
}

Strategy <|-- ConcreteStrategy : "is-a"
class ConcreteStrategy{
    run() %%Override%%
}
```

## Real Life usecase
### Payment Method (has-a)
- UPI : pay()
- Card : pay()
- Net Banking : pay()

### Sorting Class (DSA Example)
- Insertion <--is a-- NormalInsertionSort, RandomizedInsertionSort
- MergeSort <--is a-- NormalMergeSort, RandomizedMergeSort


## Conclusion
- Encapsulate what changes and keep it seperate from what remain same.
- Solution to Inheritance is : not more inheritance
- Composition should be favored over Inheritance
- Code to Interface and not to Concretion
- Do Not Repeate Yourself